<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home | Docker, Linux and Containerization</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container-fluid">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container">
                <a class="navbar-brand" href="index.html">Docker, Linux and Containerization</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                    aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link" href="index.html">Home</a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                                data-bs-toggle="dropdown" aria-expanded="false">
                                Topics
                            </a>
                            <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                                <li><a class="dropdown-item" href="virtualization.html">Virtualization</a></li>
                                <li><a class="dropdown-item" href="containerization.html">Containerization</a></li>
                                <li><a class="dropdown-item" href="compare.html">How do they compare</a></li>
                                <li><a class="dropdown-item" href="webserver.html">Setup a web server with Docker</a></li>
                                <li><a class="dropdown-item" href="linux.html">Linux commands</a></li>
                                <li><a class="dropdown-item" href="pycharm.html">Connect docker with Pycharm</a></li>


                            </ul>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="about.html">About</a>
                        </li>
                    </ul>
                    <form class="d-flex">
                        <a class="btn btn-outline-success"
                            href="https://github.com/karthik892/cs601-dockerlinuxcontainerization">View on
                            GitHub</a>
                    </form>
                </div>
            </div>
        </nav>
    </div>


    <div class="container pb-5">
        <div class="row pt-3 pb-3 px-4">

            <div class="col-lg-6 mb-5 my-lg-auto">
                <h3 class="text-dark mb-3">
                    What is the difference between Virtualization and Containerization?
                </h3>
                <p>
                    1. The advantage of multiple copies: one of the major points that differentiate these two processes is
                    containers’ temporary behavior. Many copies of a container can exist at the same time in a system like
                    orchestration. If any containers failed, one can remove that and replace it, and there will be no change
                    or impact on service. Older versions can exist at the same time with the new versions. Removal and
                    replacement of the new versions can be done easily if any operation gets failed.
                </p>
                <p>
                    2. Scaling related workloads: There is a vast difference between the scalability of a containerized
                    workload and a virtual workload. The containers contain only those services which are basic in nature
                    and which their functions require, but among those services, one can be a web server like Nginx and
                    virtualization workload system, like cabernets, having the capability of judging that when there is a
                    need of scaling out the number of containers based on the sequence of traffic follows and can copy the
                    images of the container on its own and also remove them from the system.
                </p>
                <p>
                    3. Foundation for running an application: the Linux containers format is the foundation for
                    containerization format. So, containerization can only run the Linux application as it will support only
                    the Linux environment.
                </p>
                <p>
                    4. Using microservices architecture: Google firstly uses the architecture “microservices” and then by
                    Netflix. One can operate these systems without excluding any single application. In the form of
                    functions, they perform small workloads that may be contacted through API, and they perform different
                    functions. These functions can be seen in traditional applications, although many applications can
                    perform the same functions on repeat.
                </p>
            </div>

            <div class="col-lg-6 mb-5 my-lg-auto">
                <h3 class="text-dark mb-3">
                    Containerization vs Virtualization: Which one is better!
                </h3>
                <p class="lead mb-4">
                    The assurance of which is better in Containers versus Virtual Machines (VMs) relies upon your objective.
                    However, virtualization empowers remaining tasks at hand to keep running in situations that are isolated
                    from their basic equipment by a layer of reflection. This reflection enables servers to be separated
                    into VMs that can run distinctive working frameworks.
                </p>
                <p>
                    Container innovation offers an elective strategy for Virtualization, in which a solitary working
                    framework on a host can run a wide range of users from the cloud. One approach to consider Containers
                    versus VMs is that while VMs run a few distinctive working frameworks on one process hub, while
                    containers offer the chance to virtualize the working framework itself.
                </p>
                <p>
                    Containerization and Virtualization differ in many ways, but the primary difference is that containers
                    provide a way to virtualize an OS to run multiple workloads in a single OS instance. With VMs, the
                    hardware is virtualized to run multiple OS instances. The speed, agility, and portability of the
                    container make it another tool to streamline software development.
                </p>
            </div>
    <div class="container">
       <div class="row">
           <div class="col-12">
               <h2>Containers vs Virtualization</h2>
           </div>
           <div class="col-12">
            <p>In traditional virtualization, a hypervisor virtualizes physical hardware. The result is that each virtual machine contains a guest OS, a virtual copy of the hardware that the OS requires to run, and an application and its associated libraries and dependencies.</p>
            <p>Instead of virtualizing the underlying hardware, containers virtualize the operating system (typically Linux) so each individual container contains only the application and its libraries and dependencies. Containers are small, fast, and portable because unlike a virtual machine, containers do not need to include a guest OS in every instance and can, instead, simply leverage the features and resources of the host OS.</p>
            <p>Just like virtual machines, containers allow developers to improve CPU and memory utilization of physical machines. Containers go even further, however, because they also enable microservice architectures, where application components can be deployed and scaled more granularly. This is an attractive alternative to having to scale up an entire monolithic application because a single component is struggling with load.</p>
           </div>
           <div class="col-12">
               <p><strong>Containers</strong> are typically measured by the megabyte. They don’t package anything bigger than an app and all the files necessary to run, and are often used to package single functions that perform specific tasks (known as a microservice). The lightweight nature of containers—and their shared operating system (OS)—makes them very easy to move across multiple environments.</p>
               <p><strong>VMs</strong> are typically measured by the gigabyte. They usually contain their own OS, allowing them to perform multiple resource-intensive functions at once. The increased resources available to VMs allow them to abstract, split, duplicate, and em</p>
           </div>
           <div class="col-12">
               <h2>Which one should I Use</h2>
               <p>That depends—do you need a small instance of something that can be moved easily (containers), or do you need a semi-permanent allocation of custom IT resources?</p>
               <p>The small, lightweight nature of containers allows them to be moved easily across bare metal systems as well as public, private, hybrid, and multicloud environments. They’re also the ideal environment to deploy today’s cloud-native apps, which are collections of microservices designed to provide a consistent development and automated  management experience across public, private, hybrid, and multicloud environments. Cloud-native apps help speed up how new apps are built, how existing ones are optimized, how they’re all connected. The caveat is that containers have to be compatible with the underlying OS. Compared to VMs, containers are best used to: </p>
               <ul>
                   <li>Build cloud-native apps</li>
                   <li>Package microservices</li>
                   <li>Instill DevOps or CI/CD practices</li>
                   <li>Move scalable IT projects across a diverse IT footprint that shares the same OS</li>
               </ul>
               <p>VMs are capable of running far more operations than a single container, which is why they are the traditional way monolothic workloads have been (and are still today) packaged. But that expanded functionality makes VMs far less portable because of their dependence on the OS, application, and libraries. Compared to containers, VMs are best used to:</p>
               <ul>
                   <li>House traditional, legacy, and monolothic workloads</li>
                   <li>Isolate risky development cycles</li>
                   <li>Provision infrastructural resources (such as networks, servers, and data)</li>
                   <li>Run a different OS inside another OS (such as running Unix on Linux)</li>
               </ul>
           </div>
           <div class="col-12"></div>
       </div>
    </div>



    <div class="container">
        <div class="row">
            <div class="col-12">
                <h2>References</h2>
            </div>
            <div class="col-12">
                <ul>
                    <li><a href="https://www.ibm.com/cloud/blog/containers-vs-vms">Containers vs VM's: Whats the difference | IBM</a></li>
                    <li><a href="https://www.redhat.com/en/topics/containers/containers-vs-vms">Containers vs VMs | Red Hat</a></li>
                </ul>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
        crossorigin="anonymous"></script>

</body>

</html>