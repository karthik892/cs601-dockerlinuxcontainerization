<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home | Docker, Linux and Containerization</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container-fluid">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container">
                <a class="navbar-brand" href="index.html">Docker, Linux and Containerization</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                    aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link" href="index.html">Home</a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                                data-bs-toggle="dropdown" aria-expanded="false">
                                Topics
                            </a>
                            <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                                <li><a class="dropdown-item" href="virtualization.html">Virtualization</a></li>
                                <li><a class="dropdown-item" href="containerization.html">Containerization</a></li>
                                <li><a class="dropdown-item" href="compare.html">How do they compare</a></li>
                                <li><a class="dropdown-item" href="webserver.html">Setting up a local web server with
                                        Docker</a></li>
                                <li><a class="dropdown-item" href="linux.html">Linux commands</a></li>
                                <li><a class="dropdown-item" href="pycharm.html">Docker with PyCharm</a></li>

                            </ul>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="about.html">About</a>
                        </li>
                    </ul>
                    <form class="d-flex">
                        <a class="btn btn-outline-success"
                            href="https://github.com/karthik892/cs601-dockerlinuxcontainerization">View on
                            GitHub</a>
                    </form>
                </div>
            </div>
        </nav>
    </div>

    <div class="container">
       <div class="row">
           <div class="col-12">
               <h2>Containers vs Virtualization</h2>
           </div>
           <div class="col-12">
            <p>In traditional virtualization, a hypervisor virtualizes physical hardware. The result is that each virtual machine contains a guest OS, a virtual copy of the hardware that the OS requires to run, and an application and its associated libraries and dependencies.</p>
            <p>Instead of virtualizing the underlying hardware, containers virtualize the operating system (typically Linux) so each individual container contains only the application and its libraries and dependencies. Containers are small, fast, and portable because unlike a virtual machine, containers do not need to include a guest OS in every instance and can, instead, simply leverage the features and resources of the host OS.</p>
            <p>Just like virtual machines, containers allow developers to improve CPU and memory utilization of physical machines. Containers go even further, however, because they also enable microservice architectures, where application components can be deployed and scaled more granularly. This is an attractive alternative to having to scale up an entire monolithic application because a single component is struggling with load.</p>
           </div>
           <div class="col-12">
               <p><strong>Containers</strong> are typically measured by the megabyte. They don’t package anything bigger than an app and all the files necessary to run, and are often used to package single functions that perform specific tasks (known as a microservice). The lightweight nature of containers—and their shared operating system (OS)—makes them very easy to move across multiple environments.</p>
               <p><strong>VMs</strong> are typically measured by the gigabyte. They usually contain their own OS, allowing them to perform multiple resource-intensive functions at once. The increased resources available to VMs allow them to abstract, split, duplicate, and em</p>
           </div>
           <div class="col-12">
               <h2>Which one should I Use</h2>
               <p>That depends—do you need a small instance of something that can be moved easily (containers), or do you need a semi-permanent allocation of custom IT resources?</p>
               <p>The small, lightweight nature of containers allows them to be moved easily across bare metal systems as well as public, private, hybrid, and multicloud environments. They’re also the ideal environment to deploy today’s cloud-native apps, which are collections of microservices designed to provide a consistent development and automated  management experience across public, private, hybrid, and multicloud environments. Cloud-native apps help speed up how new apps are built, how existing ones are optimized, how they’re all connected. The caveat is that containers have to be compatible with the underlying OS. Compared to VMs, containers are best used to: </p>
               <ul>
                   <li>Build cloud-native apps</li>
                   <li>Package microservices</li>
                   <li>Instill DevOps or CI/CD practices</li>
                   <li>Move scalable IT projects across a diverse IT footprint that shares the same OS</li>
               </ul>
               <p>VMs are capable of running far more operations than a single container, which is why they are the traditional way monolothic workloads have been (and are still today) packaged. But that expanded functionality makes VMs far less portable because of their dependence on the OS, application, and libraries. Compared to containers, VMs are best used to:</p>
               <ul>
                   <li>House traditional, legacy, and monolothic workloads</li>
                   <li>Isolate risky development cycles</li>
                   <li>Provision infrastructural resources (such as networks, servers, and data)</li>
                   <li>Run a different OS inside another OS (such as running Unix on Linux)</li>
               </ul>
           </div>
           <div class="col-12"></div>
       </div>
    </div>



    <div class="container">
        <div class="row">
            <div class="col-12">
                <h2>References</h2>
            </div>
            <div class="col-12">
                <ul>
                    <li><a href="https://www.ibm.com/cloud/blog/containers-vs-vms">Containers vs VM's: Whats the difference | IBM</a></li>
                    <li><a href="https://www.redhat.com/en/topics/containers/containers-vs-vms">Containers vs VMs | Red Hat</a></li>
                </ul>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
        crossorigin="anonymous"></script>

</body>

</html>